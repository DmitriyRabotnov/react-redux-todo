Currently, we will read the params.filter passed by the router or inside the App component. We can access the params from there, because the router injects params prop into any Route handler component specified in the route configuration. In this case, the :filter is passed inside params.

Root.js

const Root = ({ store }) => (
  <Provider store={store}>
    <Router history={broswerHistory}>
      <Route path="/(:filter)" component={App} />
    </Router>
  </Provider>
);
App.js

const App = ({ params }) => (
  <div>
    <AddTodo />
    <VisibleTodoList
      filter={parms.filter || 'all'}
    />
    <Footer />
  </div>
);
However, the App component itself does not really use filter. It just passes the filter down to the VisibleTodoList, which uses it to calculate the currently visible todos. Passing the params from the top level of route handlers gets tedious, so I'm removing the filter prop. Instead, I'm going to find a way to read the current router params in the VisibleTodoList itself.

App.js

const App = () => (
  <div>
    <AddTodo />
    <VisibleTodoList />
    <Footer />
  </div>
);
I will add a new import called withRouter from the react-router package. It's important that we use at least React Router 3.0 for it to work well with Redux.  withRouter, it takes a React component and returns a different React component that injects the router-related props, such as params, into your component.

VisibleTodoList.js

import { withRouter } from 'react-router';
I want the params to be available inside mapStateToProps, so I need to wrap the connectresult so that the connected component gets the params as a prop.

VisibleTodoList.js

const VisibleTodoList = withRouter(connect(
  mapStateToProps,
  mapDispatchToProps
)(TodoList));
I can scroll up a little bit to the mapStateToProps definition and I can change it so that, rather than read filter directly from ownProps, it's going to read it from ownProps.params.

VisibleTodoList.js

const mapStateToProps = (state, ownProps) => ({
  todos: getVisibleTodos(
    state.todos,
    ownProps.parms.filter
  ),
});
Finally, I specify the fallback value, just like I used to do in the app component. To make it more compact, I'm reading the params right inside the argument definition thanks to ES6's destructuring syntax.

VisibleTodoList.js

const mapStateToProps = (state, { params }) => ({
  todos: getVisibleTodos(state.todos, parms.filter || 'all'),
});
Let's recap how we made the router params available inside the connected components' mapStateToPropsfunction. We'll read the params from the ownPropsargument, which corresponds to the props passed from the parent component. The params props specifically is passed by the component generated by withRouter call. This is how they end up in props of our connected component.

VisibleTodoList.js

const mapStateToProps = (state, { params }) => ({
  todos: getVisibleTodos(state.todos, parms.filter || 'all'),
});
withRouter passes any props through itself, so we're going to see both params, and any props passed from the app in the ownProps argument. Finally, I import withRouter from the React Router package. It only works correctly with connect since React Router 3.0, so make sure you're on the recent version.

VisibleTodoList.js

const VisibleTodoList = withRouter(connect(
  mapStateToProps,
  mapDispatchToProps
)(TodoList));
VisibleTodoList.js

import { connect } from 'react-redux';
import { withRouter } from 'react-router';
The params injected by withRouter are the same exact params that get injected by default into the route handler components. You can use both ways of getting to the params and even mix them, but withRouter is handy when you need to read the current params somewhere deep in the component tree.